## API Report File for "@acoustic-content-sdk/utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractElement } from '@acoustic-content-sdk/api';
import { AuthoringElement } from '@acoustic-content-sdk/api';
import { AuthoringGroup } from '@acoustic-content-sdk/api';
import { AuthoringGroupElement } from '@acoustic-content-sdk/api';
import { AuthoringImage } from '@acoustic-content-sdk/api';
import { AuthoringLayoutItem } from '@acoustic-content-sdk/api';
import { AuthoringLayoutMapping } from '@acoustic-content-sdk/api';
import { AuthoringPlaceholder } from '@acoustic-content-sdk/api';
import { AuthoringReference } from '@acoustic-content-sdk/api';
import { AuthoringReferenceValue } from '@acoustic-content-sdk/api';
import { AuthoringText } from '@acoustic-content-sdk/api';
import { AuthoringType } from '@acoustic-content-sdk/api';
import { AuthoringVideo } from '@acoustic-content-sdk/api';
import { Category } from '@acoustic-content-sdk/api';
import { CategoryElement } from '@acoustic-content-sdk/api';
import { ContentItemWithLayout } from '@acoustic-content-sdk/api';
import { CYCLE_HANDLING } from '@acoustic-content-sdk/api';
import { DateElement } from '@acoustic-content-sdk/api';
import { DeliveryContentItem } from '@acoustic-content-sdk/api';
import { DeliveryContentMetadata } from '@acoustic-content-sdk/api';
import { DeliveryElement } from '@acoustic-content-sdk/api';
import { DeliveryLayout } from '@acoustic-content-sdk/api';
import { DeliveryLayoutMapping } from '@acoustic-content-sdk/api';
import { DeliveryReferenceElement } from '@acoustic-content-sdk/api';
import { DeliveryType } from '@acoustic-content-sdk/api';
import { Element } from '@acoustic-content-sdk/api';
import { ELEMENT_TYPE } from '@acoustic-content-sdk/api';
import { ErrorResponse } from '@acoustic-content-sdk/api';
import { ExtendedContextV2 } from '@acoustic-content-sdk/api';
import { File } from '@acoustic-content-sdk/api';
import { FileElement } from '@acoustic-content-sdk/api';
import { FormattedTextElement } from '@acoustic-content-sdk/api';
import { GroupElement } from '@acoustic-content-sdk/api';
import { HttpResourceOptions } from '@acoustic-content-sdk/api';
import { HubInfo } from '@acoustic-content-sdk/api';
import { HubInfoUrlProvider } from '@acoustic-content-sdk/api';
import { identity } from 'rxjs';
import { Image } from '@acoustic-content-sdk/api';
import { ImageElement } from '@acoustic-content-sdk/api';
import { InteropObservable } from 'rxjs';
import { isObservable } from 'rxjs';
import { Layout } from '@acoustic-content-sdk/api';
import { Link } from '@acoustic-content-sdk/api';
import { LinkElement } from '@acoustic-content-sdk/api';
import { Locale } from '@acoustic-content-sdk/api';
import { LocalizedContext } from '@acoustic-content-sdk/api';
import { LocalizedText } from '@acoustic-content-sdk/api';
import { Location } from '@acoustic-content-sdk/api';
import { LocationElement } from '@acoustic-content-sdk/api';
import { Logger } from '@acoustic-content-sdk/api';
import { LoggerFactory } from '@acoustic-content-sdk/api';
import { LoggerService } from '@acoustic-content-sdk/api';
import { MonoTypeOperatorFunction } from 'rxjs';
import { MultiDateElement } from '@acoustic-content-sdk/api';
import { MultiFileElement } from '@acoustic-content-sdk/api';
import { MultiFormattedTextElement } from '@acoustic-content-sdk/api';
import { MultiGroupElement } from '@acoustic-content-sdk/api';
import { MultiImageElement } from '@acoustic-content-sdk/api';
import { MultiLinkElement } from '@acoustic-content-sdk/api';
import { MultiNumberElement } from '@acoustic-content-sdk/api';
import { MultiOptionSelectionElement } from '@acoustic-content-sdk/api';
import { MultiProductElement } from '@acoustic-content-sdk/api';
import { MultiReferenceElement } from '@acoustic-content-sdk/api';
import { MultiTextElement } from '@acoustic-content-sdk/api';
import { MultiToggleElement } from '@acoustic-content-sdk/api';
import { MultiVideoElement } from '@acoustic-content-sdk/api';
import { noop } from 'rxjs';
import { NumberElement } from '@acoustic-content-sdk/api';
import { Observable } from 'rxjs';
import { ObservableInput } from 'rxjs';
import { Observer } from 'rxjs';
import { OperatorFunction } from 'rxjs';
import { OptionSelectionElement } from '@acoustic-content-sdk/api';
import { ProductElement } from '@acoustic-content-sdk/api';
import { ReferenceElement } from '@acoustic-content-sdk/api';
import { RenderingContext } from '@acoustic-content-sdk/api';
import { RenderingContextInterceptor } from '@acoustic-content-sdk/api';
import { RenderingContextProvider } from '@acoustic-content-sdk/api';
import { RenderingContextV2 } from '@acoustic-content-sdk/api';
import { ReplaySubject } from 'rxjs';
import { SchedulerLike } from 'rxjs';
import { SdkMessageHandler } from '@acoustic-content-sdk/api';
import { SdkMessageHandlerCallback } from '@acoustic-content-sdk/api';
import { SingleDateElement } from '@acoustic-content-sdk/api';
import { SingleFileElement } from '@acoustic-content-sdk/api';
import { SingleFormattedTextElement } from '@acoustic-content-sdk/api';
import { SingleGroupElement } from '@acoustic-content-sdk/api';
import { SingleImageElement } from '@acoustic-content-sdk/api';
import { SingleLinkElement } from '@acoustic-content-sdk/api';
import { SingleNumberElement } from '@acoustic-content-sdk/api';
import { SingleOptionSelectionElement } from '@acoustic-content-sdk/api';
import { SingleProductElement } from '@acoustic-content-sdk/api';
import { SingleReferenceElement } from '@acoustic-content-sdk/api';
import { SingleTextElement } from '@acoustic-content-sdk/api';
import { SingleToggleElement } from '@acoustic-content-sdk/api';
import { SingleVideoElement } from '@acoustic-content-sdk/api';
import { Site } from '@acoustic-content-sdk/api';
import { SiteContext } from '@acoustic-content-sdk/api';
import { SitePage } from '@acoustic-content-sdk/api';
import { StaticHubInfoUrlProvider } from '@acoustic-content-sdk/api';
import { Subject } from 'rxjs';
import { Subscribable } from 'rxjs';
import { TextElement } from '@acoustic-content-sdk/api';
import { ToggleElement } from '@acoustic-content-sdk/api';
import { UnaryFunction } from 'rxjs';
import { Unsubscribable } from 'rxjs';
import { UrlConfig } from '@acoustic-content-sdk/api';
import { Video } from '@acoustic-content-sdk/api';
import { VideoElement } from '@acoustic-content-sdk/api';
import { WchSdkSearch } from '@acoustic-content-sdk/api';
import { WchSdkVersion } from '@acoustic-content-sdk/api';

// @public
export function absoluteURL(aUrl: string, aDoc?: Document, aWindow?: Window): string;

// @public
export const and: <T>(aLeft: Predicate<T>, aRight: Predicate<T>) => Predicate<T>;

// @public (undocumented)
export const anyToString: (aValue: any) => string;

// @public
export const arrayEquals: <T>(aLeft: T[], aRight: T[], aPredicate: EqualsPredicate<T>) => boolean;

// @public
export const arrayPush: <T>(aValue: T, aArray: T[]) => T[];

// @public (undocumented)
export const assertArray: <T>(aKey: string | number | symbol, aObject: any) => T[];

// @public (undocumented)
export const assertFromFunction: <T, K extends string | number | symbol = string | number | symbol>(aKey: K, aObject: any, aCallback: UnaryFunction<K, T>) => any;

// @public (undocumented)
export const assertFromGenerator: <T>(aKey: string | number | symbol, aObject: any, aGenerator: Generator<T>) => T;

// @public (undocumented)
export const assertObject: <T>(aKey: string | number | symbol, aObject: any) => T;

// @public (undocumented)
export const assignObject: typeof Object.assign;

// @public
export const authoringLayoutMappingToDeliveryLayoutMapping: UnaryFunction<AuthoringLayoutMapping, DeliveryLayoutMapping>;

// @public
export const authoringLayoutToDeliveryLayout: UnaryFunction<AuthoringLayoutItem, DeliveryLayout>;

// @public
export const authoringTypeToDeliveryType: UnaryFunction<AuthoringType, DeliveryType>;

// @public
export const biCompose: <S1, S2, D1, D2, R>(aFirst: UnaryFunction<S1, D1>, aSecond: UnaryFunction<S2, D2>, aFct: BiFunction<D1, D2, R>) => BiFunction<S1, S2, R>;

// @public
export const biComposeMono: <S, D, R>(aTransform: UnaryFunction<S, D>, aFct: BiFunction<D, D, R>) => BiFunction<S, S, R>;

// @public (undocumented)
export type BiConsumer<T1, T2> = BiFunction<T1, T2, any>;

// @public (undocumented)
export type BiFunction<T1, T2, R> = (t1: T1, t2: T2) => R;

// @public
export const binary: <T1, T2, R>(aFunction: BiFunction<T1, T2, R>) => BiFunction<T1, T2, R>;

// @public
export function binarySearch<T, K = T>(arr: ArrayLike<T>, x: K, cmp: BiFunction<T, K, number>): number;

// @public (undocumented)
export interface Bind {
    // (undocumented)
    <TH, R>(func: Function0<R>, aThis: TH): Function0<R>;
    // (undocumented)
    <TH, T1, R>(func: Function1<T1, R>, aThis: TH): Function1<T1, R>;
    // (undocumented)
    <TH, T1, R>(func: Function1<T1, R>, aThis: TH, arg1: T1): Function0<R>;
    // (undocumented)
    <TH, T1, T2, R>(func: Function2<T1, T2, R>, aThis: TH): Function2<T1, T2, R>;
    // (undocumented)
    <TH, T1, T2, R>(func: Function2<T1, T2, R>, aThis: TH, arg1: T1): Function1<T2, R>;
    // (undocumented)
    <TH, T1, T2, R>(func: Function2<T1, T2, R>, aThis: TH, arg1: T1, arg2: T2): Function0<R>;
    // (undocumented)
    <TH, T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, aThis: TH): Function3<T1, T2, T3, R>;
    // (undocumented)
    <TH, T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, aThis: TH, arg1: T1): Function2<T2, T3, R>;
    // (undocumented)
    <TH, T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, aThis: TH, arg1: T1, arg2: T2): Function1<T3, R>;
    // (undocumented)
    <TH, T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, aThis: TH, arg1: T1, arg2: T2, arg3: T3): Function0<R>;
    // (undocumented)
    <TH, T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, aThis: TH): Function4<T1, T2, T3, T4, R>;
    // (undocumented)
    <TH, T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, aThis: TH, arg1: T1): Function3<T2, T3, T4, R>;
    // (undocumented)
    <TH, T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, aThis: TH, arg1: T1, arg2: T2): Function2<T3, T4, R>;
    // (undocumented)
    <TH, T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, aThis: TH, arg1: T1, arg2: T2, arg3: T3): Function1<T4, R>;
    // (undocumented)
    <TH, T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, aThis: TH, arg1: T1, arg2: T2, arg3: T3, arg4: T4): Function0<R>;
}

// @public
export const bind: Bind;

// @public (undocumented)
export interface BindKey {
    // (undocumented)
    <TH, K extends keyof TH, V extends TH[K] & Function0<R>, R>(aKey: K): Function1<TH, R>;
    // (undocumented)
    <TH, T1, K extends keyof TH, V extends TH[K] & Function1<T1, R>, R>(aKey: K): Function2<TH, T1, R>;
    // (undocumented)
    <TH, T1, K extends keyof TH, V extends TH[K] & Function1<T1, R>, R>(aKey: K, aArg1: T1): Function1<TH, R>;
    // (undocumented)
    <TH, T1, T2, K extends keyof TH, V extends TH[K] & Function2<T1, T2, R>, R>(aKey: K): Function3<TH, T1, T2, R>;
    // (undocumented)
    <TH, T1, T2, K extends keyof TH, V extends TH[K] & Function2<T1, T2, R>, R>(aKey: K, aArg1: T1): Function2<TH, T2, R>;
    // (undocumented)
    <TH, T1, T2, K extends keyof TH, V extends TH[K] & Function2<T1, T2, R>, R>(aKey: K, aArg1: T1, aArg2: T2): Function1<TH, R>;
}

// @public
export const bindKey: BindKey;

// @public (undocumented)
export interface BindMember {
    // (undocumented)
    <TH, K extends keyof TH, V extends TH[K] & Function0<R>, R>(aThis: TH, aKey: K): Function0<R>;
    // (undocumented)
    <TH, T1, K extends keyof TH, V extends TH[K] & Function1<T1, R>, R>(aThis: TH, aKey: K): Function1<T1, R>;
    // (undocumented)
    <TH, T1, K extends keyof TH, V extends TH[K] & Function1<T1, R>, R>(aThis: TH, aKey: K, aArg1: T1): Function0<R>;
    // (undocumented)
    <TH, T1, T2, K extends keyof TH, V extends TH[K] & Function2<T1, T2, R>, R>(aThis: TH, aKey: K): Function2<T1, T2, R>;
    // (undocumented)
    <TH, T1, T2, K extends keyof TH, V extends TH[K] & Function2<T1, T2, R>, R>(aThis: TH, aKey: K, aArg1: T1): Function1<T2, R>;
    // (undocumented)
    <TH, T1, T2, K extends keyof TH, V extends TH[K] & Function2<T1, T2, R>, R>(aThis: TH, aKey: K, aArg1: T1, aArg2: T2): Function0<R>;
}

// @public
export const bindMember: BindMember;

// @public
export const byProperty: <T, K extends keyof T>(aKey: K, aPredicate: Predicate<T[K]>) => Predicate<T>;

// @public (undocumented)
export type CacheAccessor<V> = (aKey: string, aCallback: CacheCallback<V>, aLogger?: Logger) => V;

// @public (undocumented)
export type CacheCallback<V> = (aKey: string, aLogger?: Logger) => V;

// @public
export function cacheLast<T>(aEqualFunction?: EqualsPredicate<T>, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;

// @public (undocumented)
export let cancelExecuteLater: (aHandle: number) => void;

// @public
export function chunkArray<T>(aArray: ArrayLike<T> | null | undefined, aSize: number): T[][];

// @public (undocumented)
export interface ClientStorage {
    // (undocumented)
    get(aKey: string): JSONValue | null | undefined;
    // (undocumented)
    put(aKey: string, aValue: JSONValue): any;
}

// @public
export function clientStorageFromWindow(aScope: string, aWindow?: Window): ClientStorage;

// @public (undocumented)
export class ClientStorageService implements ClientStorage {
    constructor(aUrlsService: UrlConfig, aWindow?: Window);
    // (undocumented)
    get: (aKey: string) => JSONValue;
    // (undocumented)
    put: (aKey: string, aValue: JSONValue) => void;
}

// @public
export function cloneDeep(aValue: any): any;

// @public
export const cloneURL: UnaryFunction<URL, URL>;

// @public
export function cloneUrlConfig(aUrlConfig: UrlConfig): UrlConfig;

// @public
export const cmpByLocalizedContext: UnaryFunction<LocalizedContext, Comparator<LocalizedText>>;

// @public
export const cmpNumbers: Comparator<number>;

// @public
export const cmpStrings: Comparator<string>;

// @public
export type Comparator<T> = BiFunction<T, T, number>;

// @public
export const compose: <T1, T2, R>(aLeft: UnaryFunction<T1, T2>, aRight: UnaryFunction<T2, R>) => UnaryFunction<T1, R>;

// @public
export const composeAll: <T, R>(...aFunctions: Array<(...aAny: any[]) => any>) => UnaryFunction<T, R>;

// @public (undocumented)
export const constGenerator: <T>(aValue: T) => () => T;

// @public (undocumented)
export type Consumer<T> = UnaryFunction<T, any>;

// @public
export const createCache: <V>(aTimeout?: number, aMaxValues?: number, aLogger?: Logger) => CacheAccessor<V>;

// @public (undocumented)
export const createConsoleLogger: UnaryFunction<string, Logger>;

// @public
export const createConsumerOnSubject: <T>(aSubject: Subject<T> | Observer<T>) => Consumer<T>;

// @public
export function createDeliveryContentItem(aItem: ContentItemWithLayout): DeliveryContentItem;

// @public
export function createDeliveryContentItemWithMetadata(aItem: DeliveryContentItem): DeliveryContentItem;

// @public (undocumented)
export const createEmptyLogger: UnaryFunction<string, Logger>;

// @public (undocumented)
export function createError(aMessage: string, aCause?: Error): Error;

// @public
export function createGetter<T>(aGetter: Generator<T>): PropertyDescriptor;

// @public
export function createGetterOnObservable<T>(aObservable: Observable<T>, aInitial?: T): PropertyDescriptor;

// @public
export function createLoggerService(aLoggerFactory: LoggerFactory): LoggerService;

// @public
export const createLruCache: <V>(aTimeout?: number, aMaxValues?: number, aLogger?: Logger) => CacheAccessor<V>;

// @public
export function createMarkupRendererV2(aDeliveryContent: UnaryFunction<string, Observable<DeliveryContentItem>>, aAuthoringType: UnaryFunction<string, Observable<AuthoringType>>, aLayoutMapping: UnaryFunction<string, Observable<AuthoringLayoutMapping>>, aLayout: UnaryFunction<string, Observable<Layout>>, aMarkupTemplate: UnaryFunction<string, Observable<MarkupTemplate>>, aExtendedContext$: Observable<ExtendedContextV2>, aLoggerService: LoggerService, aScheduler?: SchedulerLike): (aId: string, aLayoutMode?: string) => Observable<string>;

// @public
export function createMessageHandler(aCorsWhitelist: Generator<PromiseLike<string[]>>, aMsgHandlers: Generator<SdkMessageHandler[]>, aLogger?: Logger): (aEvent: MessageEvent) => void;

// @public
export function createNavigateByPathHandler(aNavigate: (aPath: string) => PromiseLike<boolean>, aLogger?: Logger): SdkMessageHandlerCallback;

// @public
export const createObservableAdaptor: <T>(aSrc: Subscribable<T>) => InteropObservable<T>;

// @public (undocumented)
export const createObserverConsumer: <T>(aSubject: Observer<T>) => ObserverConsumer<T>;

// @public
export function createRefreshHandler(aRefresh: () => any, aLogger?: Logger): SdkMessageHandlerCallback;

// @public
export function createSetModeHandler(aPublicApiHandler: Consumer<boolean>, aLogger?: Logger): SdkMessageHandlerCallback;

// @public
export function createSetterOnSubject<T>(aSubject: Subject<T>): PropertyDescriptor;

// @public
export const createSingleSubject: <T>() => ReplaySubject<T>;

// @public
export function createSubscribeActiveRouteHandler(onActiveRenderingContext: Observable<RenderingContextV2>, aLogger?: Logger): SdkMessageHandlerCallback;

// @public
export function createSubscribeModeHandler(onUsePublic: Observable<boolean>, aLogger?: Logger): SdkMessageHandlerCallback;

// @public
export function createSubscribeRouteHandler(aGetRenderingContextByPath: (aPath: string) => Observable<RenderingContextV2>, aLogger?: Logger): SdkMessageHandlerCallback;

// @public
export function createUnsubscribeHandler(aLogger?: Logger): SdkMessageHandlerCallback;

// @public
export function dbgAddSource<T>(aSource: string, aObject: T | null | undefined): T;

// @public (undocumented)
export function dbgCounter(): number;

// @public @deprecated (undocumented)
export const deepDistinctUntilChanged: <T>() => MonoTypeOperatorFunction<T>;

// @public
export const deepEquals: (aLeft: any, aRight: any) => boolean;

// @public (undocumented)
export const DEFAULT_FETCH_LEVELS = -1;

// @public (undocumented)
export const DEFAULT_HTTP_RESOURCE_OPTIONS: HttpResourceOptions;

// @public (undocumented)
export const DEFAULT_LAYOUT_MAPPING: {
    [layoutMode: string]: Layout;
};

// @public (undocumented)
export const DEFAULT_LAYOUT_MODE = "default";

// @public
export const EMPTY_JSON_OBSERVABLE: Observable<JSONValue>;

// @public (undocumented)
export const EMPTY_RENDERING_CONTEXT: RenderingContext;

// @public (undocumented)
export const EMPTY_SITE_CONTEXT: SiteContext;

// @public
export const EMPTY_STRING_OBSERVABLE: Observable<string>;

// @public (undocumented)
export type EqualsPredicate<T> = (aLeft: T, aRight: T) => boolean;

// @public
export const escapeHtml: <T = string>(aValue: T) => string | T;

// @public (undocumented)
export let executeLater: (aFct: Function) => number;

// @public
export const FALSE$: Observable<boolean>;

// @public
export function filterArray<T>(aArray: ArrayLike<T>, aPredicate: Predicate<T>): T[];

// @public
export const filterArrayOf: <T>(pred: IsPredicate<T>) => OperatorFunction<any, T[]>;

// @public @deprecated (undocumented)
export const filterBoolean: Generator<MonoTypeOperatorFunction<boolean>>;

// @public @deprecated (undocumented)
export const filterNotNil: <T>() => MonoTypeOperatorFunction<T>;

// @public @deprecated (undocumented)
export const filterNumber: Generator<MonoTypeOperatorFunction<number>>;

// @public @deprecated (undocumented)
export const filterObject: Generator<MonoTypeOperatorFunction<object>>;

// @public @deprecated (undocumented)
export const filterString: Generator<MonoTypeOperatorFunction<string>>;

// @public
export const filterTypeOf: <T>(aPredicate: IsPredicate<T>) => OperatorFunction<any, T>;

// @public (undocumented)
export const firstElement: <T>(aArray: T[]) => T;

// @public (undocumented)
export function flattenArray<T>(aArray: T[][]): T[];

// @public
export const flipArgs: <T1, T2, R>(aFct: BiFunction<T1, T2, R>) => BiFunction<T2, T1, R>;

// @public
export function forEach<T>(aArray: ArrayLike<T> | null | undefined, aConsumer: Consumer<T>): void;

// @public
export function forIn<T>(aObject: Record<string, T> | null | undefined, aConsumer: BiConsumer<T, string>): void;

// @public (undocumented)
export const fromGeneratorOrT: <T>(aValue: GeneratorOrT<T>) => any;

// @public
export function fromObservableOrT<T>(aValue: ObservableOrT<T>): Observable<T>;

// @public (undocumented)
export type Function0<R> = () => R;

// @public (undocumented)
export type Function1<T1, R> = (t1: T1) => R;

// @public (undocumented)
export type Function2<T1, T2, R> = (t1: T1, t2: T2) => R;

// @public (undocumented)
export type Function3<T1, T2, T3, R> = (t1: T1, t2: T2, t3: T3) => R;

// @public (undocumented)
export type Function4<T1, T2, T3, T4, R> = (t1: T1, t2: T2, t3: T3, t4: T4) => R;

// @public (undocumented)
export const FUNCTION_TYPE: "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function";

// @public
export function generateItem<T>(aGenerator: Generator<T>): Observable<T>;

// @public (undocumented)
export type Generator<T> = () => T | null | undefined;

// @public (undocumented)
export type GeneratorOrT<T> = T | (() => GeneratorOrT<T>);

// @public
export function getAuthoringConfigElements(aType: AuthoringType): AuthoringElement[];

// @public
export function getAuthoringContentElements(aType: AuthoringType): AuthoringElement[];

// @public
export function getBaseUrlFromDocument(aDoc?: Document, aWindow?: Window): URL | undefined;

// @public
export function getBaseUrlFromWindow(aWindow?: Window, aDocument?: Document): URL | undefined;

// @public
export const getCategoryLeaf: (aCategory: Category, aIndex?: number, aFallback?: string) => string;

// @public
export function getItemStatus(aRenderingContext: RenderingContext): ItemStatus;

// @public
export function getLinksByRel(aDocument?: Document, aWindow?: Window): Record<string, string>;

// @public
export function getOrigin(aDoc?: Document, aWindow?: Window): string;

// @public
export const getPath: <T>(aValue: any, aPath: ArrayLike<string>, aDefault?: T) => T;

// @public
export const getProperty: <T, K extends keyof T>(aValue: T, aKey: K, aDefault?: T[K]) => T[K];

// @public
function _getResourceUrlFromApiURL(aApiURL: URL): URL;

export { _getResourceUrlFromApiURL as wchGetDeliveryUrlFromApiURL }

export { _getResourceUrlFromApiURL as wchGetResourceUrlFromApiURL }

// @public
export const hashRandomClassName: () => string;

// @public
export const hashRandomIdentifier: () => string;

// @public
export const hashRandomLinkName: () => string;

// @public (undocumented)
export function hashString(oldHash: number, s: string): number;

// @public
export const hashToClassName: (aHash: number) => string;

// @public
export const hashToIdentifier: (aHash: number) => string;

// @public
export const hashToLinkName: (aHash: number) => string;

// @public
export function httpCreateTimer(aOptions?: HttpResourceOptions): Observable<any>;

// @public (undocumented)
export function httpGetJsonResource(aURL: string, aHttpService: HttpService, aWithCredentials: boolean, aTrigger: Observable<any>, aOptions?: HttpResourceOptions, aLogger?: Logger): Observable<JSONValue>;

// @public
export function httpGetStringResource(aURL: string, aHttpService: HttpService, aWithCredentials: boolean, aTrigger: Observable<any>, aOptions: HttpResourceOptions, aLogger?: Logger): Observable<string>;

// @public (undocumented)
export interface HttpOptions {
    // (undocumented)
    dispatchError?: boolean;
    // (undocumented)
    withCredentials: boolean;
}

// @public (undocumented)
export interface HttpService {
    // (undocumented)
    getJson<T>(aUrl: string, aOptions: HttpOptions): Observable<T>;
    // (undocumented)
    getText(aUrl: string, aOptions: HttpOptions): Observable<string>;
}

export { identity }

// @public (undocumented)
export const idleFrameScheduler: SchedulerLike;

// @public
export const isAbsoluteURL: IsPredicate<string>;

// @public
export const isArray: IsPredicate<any[]>;

// @public
export const isArrayLike: IsPredicate<ArrayLike<any>>;

// @public
export function isArrayLikeOf<T>(aValue: any, aPredicate: IsPredicate<T>): aValue is ArrayLike<T>;

// @public
export function isArrayOf<T>(aValue: any, aPredicate: IsPredicate<T>): aValue is T[];

// @public
export function isAuthoringConfigElement(aElement: AuthoringElement): boolean;

// @public
export function isAuthoringContentElement(aElement: AuthoringElement): boolean;

// @public (undocumented)
export function isAuthoringGroup<T>(value: any): value is AuthoringGroup<T>;

// @public
export function isAuthoringGroupElement(aValue: any): aValue is AuthoringGroupElement;

// @public (undocumented)
export function isAuthoringImage(value: any): value is AuthoringImage;

// @public (undocumented)
export function isAuthoringReference(value: any): value is AuthoringReference;

// @public (undocumented)
export function isAuthoringReferenceValue(value: any): value is AuthoringReferenceValue;

// @public (undocumented)
export function isAuthoringText(value: any): value is AuthoringText;

// @public (undocumented)
export function isAuthoringVideo(value: any): value is AuthoringVideo;

// @public
export const isBoolean: IsPredicate<boolean>;

// @public (undocumented)
export function isCategory(aValue: any, bOptional?: boolean): aValue is Category;

// @public
export function isCategoryElement(aValue: any, bOptional?: boolean): aValue is CategoryElement;

// @public
export function isDate(aValue: any): aValue is Date;

// @public
export function isDateElement(aValue: any): aValue is DateElement;

// @public
export const isDeepEqualTo: <T>(aComparison: T) => Predicate<T>;

// @public
export function isDeliveryReferenceElement(aValue: any): aValue is DeliveryReferenceElement;

// @public
export function isElement(aValue: any, bOptional?: boolean): aValue is Element;

// @public
export function isElementType(aValue: any): aValue is ELEMENT_TYPE;

// @public
export const isEmpty: Predicate<any[]>;

// @public (undocumented)
export function isEqual<T>(aLeft: T, aRight: T): boolean;

// @public
export const isEqualTo: <T, R = T>(aComparison: T, aTransform?: UnaryFunction<R, T>) => Predicate<R>;

// @public
export const isEqualVersion: EqualsPredicate<WchSdkVersion>;

// @public
export function isErrorResponse(aResponse: any): aResponse is ErrorResponse;

// @public
export function isFile(aValue: any, bOptional?: boolean): aValue is File;

// @public
export function isFileElement(aValue: any): aValue is FileElement;

// @public
export function isFormattedTextElement(aValue: any): aValue is FormattedTextElement;

// @public
export const isFunction: IsPredicate<Function>;

// @public
export function isGroupElement(aValue: any, bOptional?: boolean): aValue is GroupElement;

// @public
export function isImage(aValue: any, bOptional?: boolean): aValue is Image;

// @public
export function isImageElement(aValue: any): aValue is ImageElement;

// @public
export function isLink(aValue: any, bOptional?: boolean): aValue is Link;

// @public
export function isLinkElement(aValue: any): aValue is LinkElement;

// @public
export function isLocalizedText(aText: any): aText is LocalizedText;

// @public (undocumented)
export function isLocation(aValue: any, bOptional?: boolean): aValue is Location;

// @public
export function isLocationElement(aValue: any, bOptional?: boolean): aValue is LocationElement;

// @public
export function isMetadata(aValue: any): aValue is DeliveryContentMetadata;

// @public
export function isMultiDateElement(aValue: any, bOptional?: boolean): aValue is MultiDateElement;

// @public
export function isMultiFileElement(aValue: any, bOptional?: boolean): aValue is MultiFileElement;

// @public
export function isMultiFormattedTextElement(aValue: any, bOptional?: boolean): aValue is MultiFormattedTextElement;

// @public
export function isMultiGroupElement(aValue: any, bOptional?: boolean): aValue is MultiGroupElement;

// @public
export function isMultiImageElement(aValue: any, bOptional?: boolean): aValue is MultiImageElement;

// @public
export function isMultiLinkElement(aValue: any, bOptional?: boolean): aValue is MultiLinkElement;

// @public
export function isMultiNumberElement(aValue: any, bOptional?: boolean): aValue is MultiNumberElement;

// @public
export function isMultiOptionSelectionElement(aValue: any, bOptional?: boolean): aValue is MultiOptionSelectionElement;

// @public
export function isMultiProductElement(aValue: any, bOptional?: boolean): aValue is MultiProductElement;

// @public
export function isMultiReferenceElement(aValue: any, bOptional?: boolean): aValue is MultiReferenceElement;

// @public
export function isMultiTextElement(aValue: any, bOptional?: boolean): aValue is MultiTextElement;

// @public
export function isMultiToggleElement(aValue: any, bOptional?: boolean): aValue is MultiToggleElement;

// @public
export function isMultiVideoElement(aValue: any, bOptional?: boolean): aValue is MultiVideoElement;

// @public
export const isNever: IsPredicate<never>;

// @public
export const isNil: (aObject: any) => aObject is null | undefined;

// @public
export const isNilOrEmpty: <T>(aValue: any) => boolean;

// @public
export const isNotEmpty: <T>(arr: any) => arr is ArrayLike<T>;

// @public
export const isNotNil: <T>(aObject: T | null | undefined) => aObject is T;

// @public
export const isNumber: IsPredicate<number>;

// @public
export function isNumberElement(aValue: any): aValue is NumberElement;

// @public
export function isObjectOf<T>(aValue: any, aPredicate: IsPredicate<T>): aValue is {
    [key: string]: T;
};

export { isObservable }

// @public (undocumented)
export function isOptional<T>(aValue: any, aPredicate: IsPredicate<T>): aValue is T;

// @public (undocumented)
export function isOptionalArrayOf<T>(aValue: any, aPredicate: IsPredicate<T>): aValue is T[];

// @public
export function isOptionSelectionElement(aValue: any): aValue is OptionSelectionElement;

// @public
export function isPlainObject(aObject: any): aObject is object;

// @public (undocumented)
export type IsPredicate<T> = (aValue: any | null | undefined) => aValue is T;

// @public (undocumented)
export function isProductElement(aValue: any): aValue is ProductElement;

// @public
export function isReferenceElement(aValue: any): aValue is ReferenceElement;

// @public
export function isRenderingContextProvider(aValue: any): aValue is RenderingContextProvider;

// @public
export function isRenderingContextV2(aValue: any): aValue is RenderingContextV2;

// @public
export function isSingleDateElement(aValue: any, bOptional?: boolean): aValue is SingleDateElement;

// @public
export function isSingleFileElement(aValue: any, bOptional?: boolean): aValue is SingleFileElement;

// @public
export function isSingleFormattedTextElement(aValue: any, bOptional?: boolean): aValue is SingleFormattedTextElement;

// @public
export function isSingleGroupElement(aValue: any, bOptional?: boolean): aValue is SingleGroupElement;

// @public
export function isSingleImageElement(aValue: any, bOptional?: boolean): aValue is SingleImageElement;

// @public
export function isSingleLinkElement(aValue: any, bOptional?: boolean): aValue is SingleLinkElement;

// @public
export function isSingleNumberElement(aValue: any, bOptional?: boolean): aValue is SingleNumberElement;

// @public
export function isSingleOptionSelectionElement(aValue: any, bOptional?: boolean): aValue is SingleOptionSelectionElement;

// @public
export function isSingleProductElement(aValue: any, bOptional?: boolean): aValue is SingleProductElement;

// @public
export function isSingleReferenceElement(aValue: any, bOptional?: boolean): aValue is SingleReferenceElement;

// @public
export function isSingleTextElement(aValue: any, bOptional?: boolean): aValue is SingleTextElement;

// @public
export function isSingleToggleElement(aValue: any, bOptional?: boolean): aValue is SingleToggleElement;

// @public
export function isSingleVideoElement(aValue: any, bOptional?: boolean): aValue is SingleVideoElement;

// @public
export const isString: IsPredicate<string>;

// @public
export const isStringArray: IsPredicate<string[]>;

// @public
export function isTextElement(aValue: any): aValue is TextElement;

// @public
export function isToggleElement(aValue: any, bOptional?: boolean): aValue is ToggleElement;

// @public
export const isUndefined: IsPredicate<undefined>;

// @public (undocumented)
export function isURL(aValue: any): aValue is URL;

// @public
export function isUrlConfig(aValue: any): aValue is UrlConfig;

// @public
export function isValueOf(aType: string, aValue: any, bOptional?: boolean): boolean;

// @public
export function isVideo(aValue: any, bOptional?: boolean): aValue is Video;

// @public
export function isVideoElement(aValue: any): aValue is VideoElement;

// @public (undocumented)
export enum ItemStatus {
    // (undocumented)
    APPROVED_DRAFT = 1,
    // (undocumented)
    DRAFT = 0,
    // (undocumented)
    PENDING_DRAFT = 2,
    // (undocumented)
    PUBLISHED = 3
}

// @public (undocumented)
export interface JSONArray extends Array<JSONValue> {
}

// @public (undocumented)
export interface JSONObject {
    // (undocumented)
    [x: string]: JSONValue;
}

// @public (undocumented)
export const jsonParse: <T>(aValue: string) => T;

// @public (undocumented)
export const jsonStringify: UnaryFunction<any, string>;

// @public (undocumented)
export type JSONValue = boolean | number | string | null | JSONArray | JSONObject;

// @public (undocumented)
export function kebabCase(str: string): string;

// @public (undocumented)
export const KEY_CYCLE = "$$CYCLE";

// @public (undocumented)
export const KEY_LAYOUT_MODE = "layoutMode";

// @public (undocumented)
export const KEY_LEVELS = "levels";

// @public (undocumented)
export const KEY_RENDERING_CONTEXT = "renderingContext";

// @public (undocumented)
export const KEY_RENDERING_CONTEXT_MAP: string | symbol;

// @public (undocumented)
export const lastElement: <T>(aArray: T[]) => T;

// @public (undocumented)
export const LAYOUT_TYPE_ANGULAR = "angular";

// @public (undocumented)
export const LAYOUT_TYPE_HANDLEBARS = "handlebars";

// @public
export const lazyGenerator: <T>(aGenerator: Generator<T>) => Generator<T>;

// @public
export const lazyProxy: <T>(aGenerator: Generator<T>) => T;

// @public
export const localizedText: BiFunction<string, Locale, LocalizedText>;

// @public
export function logModule(aVersion: WchSdkVersion, aModule: string, aLogSvc?: LoggerService): void;

// @public
export function longHash(): number;

// @public
export function luceneEscapeKeyValue(aKey: string, aTerm: string | null | undefined): string;

// @public
export function luceneEscapeKeyValueAnd(aKey: string, ...aTerms: string[]): string;

// @public
export function luceneEscapeKeyValueOr(aKey: string, ...aTerms: string[]): string;

// @public
export function luceneEscapeTerm(aTerm: string): string;

// @public
export function mapArray<T, R>(aArray: ArrayLike<T> | null | undefined, aMapper: UnaryFunction<T, R>): R[];

// @public
export const mapDefault: <T>(aDefault: T) => MonoTypeOperatorFunction<T>;

// @public
export const mapTypeOf: <T>(aPredicate: IsPredicate<T>) => OperatorFunction<any, T>;

// @public (undocumented)
export type MarkupTemplate = UnaryFunction<RenderingContextV2, Observable<string>>;

// @public
export type Maybe<T> = NonNullable<T> | undefined;

// @public
export const mergeHubInfo: BiFunction<HubInfo, HubInfo, HubInfo>;

// @public
export function mergeObjects<T>(aLeft: T, aRight: T): T;

// @public
export const MODULE = "@acoustic-content-sdk/utils";

// @public
export function nary(aArity: number, aFunction: (...aValues: any[]) => any): (...aValues: any[]) => any;

export { noop }

// @public
export const NOOP_LOGGER_SERVICE: LoggerService;

// @public
export const not: <T>(aFunction: Predicate<T>) => Predicate<T>;

// @public
export const NULL$: Observable<any>;

// @public
export const nullary: <T>(aFunction: () => T) => () => T;

// @public
export const objectAssign: <T, V>(aKey: string, aValue: V, aObject: T) => T;

// @public
export const objectEquals: (aLeft: any, aRight: any, aPredicate: EqualsPredicate<any>) => boolean;

// @public
export const objectKeys: typeof Object.keys;

// @public (undocumented)
export type ObservableOrT<T> = GeneratorOrT<T> | Observable<GeneratorOrT<T>>;

// @public (undocumented)
export interface ObserverConsumer<T> extends Observer<T> {
    // (undocumented)
    (aValue: T): void;
}

// @public
export const opBoxLayoutMode: OperatorFunction<string, string>;

// @public
export const opCacheLast: <T>(src: Observable<T>) => Observable<T>;

// @public
export const opDeepDistinctUntilChanged: <T>(src: Observable<T>) => Observable<T>;

// @public
export const opDistinctUntilChanged: <T>(src: Observable<T>) => Observable<T>;

// @public @deprecated
export const opFalse: Observable<boolean>;

// @public
export const opFilterBoolean: OperatorFunction<any, boolean>;

// @public
export const opFilterNever: OperatorFunction<any, never>;

// @public
export const opFilterNotNil: <T>(src: Observable<T>) => Observable<NonNullable<T>>;

// @public
export const opFilterNumber: OperatorFunction<any, number>;

// @public
export const opFilterObject: OperatorFunction<any, object>;

// @public
export const opFilterString: OperatorFunction<any, string>;

// @public
export const opJsonParse: <T>(src: Observable<string>) => Observable<T>;

// @public
export const opLevels: OperatorFunction<string | number | null | undefined, number>;

// @public
export const opNot: MonoTypeOperatorFunction<boolean>;

// @public
export const opPageArrayDistinctUntilChanged: MonoTypeOperatorFunction<DeliveryContentItem[]>;

// @public
export const opPageDistinctUntilChanged: MonoTypeOperatorFunction<DeliveryContentItem>;

// @public
export const opPluckApiOrigin: OperatorFunction<RenderingContextV2, string>;

// @public
export const opPluckCurrentPage: OperatorFunction<RenderingContextV2, DeliveryContentItem>;

// @public
export const opPluckDistinctPage: OperatorFunction<RenderingContextV2, DeliveryContentItem>;

// @public
export const opPluckResourceOrigin: OperatorFunction<RenderingContextV2, string>;

// @public
export const opReplayLast: <T>(src: Observable<T>) => Observable<T>;

// @public
export const opShallowDistinctUntilChanged: <T>(src: Observable<T>) => Observable<T>;

// @public
export const opShareLast: <T>(src: Observable<T>) => Observable<T>;

// @public @deprecated
export const opTrue: Observable<boolean>;

// @public
export const or: <T>(aLeft: Predicate<T>, aRight: Predicate<T>) => Predicate<T>;

// @public @deprecated (undocumented)
export const pageArrayDistinctUntilChanged: Generator<MonoTypeOperatorFunction<DeliveryContentItem[]>>;

// @public
export function pageArrayEquals(aLeft: DeliveryContentItem[], aRight: DeliveryContentItem[]): boolean;

// @public
export function pageCloneSitePage(aSitePage: SitePage): SitePage;

// @public
export function pageCreatePartialSiteContextForSitePage(aPage: SitePage, aSite: Site): SiteContext;

// @public
export function pageCreateSiteContextFromSearchResult(aPage: SitePage, aSearchResult: SitePage[], aSite: Site): SiteContext;

// @public @deprecated (undocumented)
export const pageDistinctUntilChanged: Generator<MonoTypeOperatorFunction<DeliveryContentItem>>;

// @public
export function pageEquals(aLeft: DeliveryContentItem, aRight: DeliveryContentItem): boolean;

// @public
export const pageFromRenderingContext: UnaryFunction<RenderingContextV2, DeliveryContentItem>;

// @public
export function pageGetEncodedPath(aPath: string): string;

// @public (undocumented)
export type ParsedQuery = Record<string, string | string[]>;

// @public
export const parsePath: UnaryFunction<string, string[]>;

// @public
export function parseQueryString(aQuery: string): ParsedQuery;

// @public
export const parseURL: UnaryFunction<URL | string | null | undefined, URL | null | undefined>;

// @public (undocumented)
export interface Partial {
    // (undocumented)
    <R>(func: Function0<R>): Function0<R>;
    // (undocumented)
    <T1, R>(func: Function1<T1, R>): Function1<T1, R>;
    // (undocumented)
    <T1, R>(func: Function1<T1, R>, arg1: T1): Function0<R>;
    // (undocumented)
    <T1, T2, R>(func: Function2<T1, T2, R>): Function2<T1, T2, R>;
    // (undocumented)
    <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1): Function1<T2, R>;
    // (undocumented)
    <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, arg2: T2): Function0<R>;
    // (undocumented)
    <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>): Function3<T1, T2, T3, R>;
    // (undocumented)
    <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1): Function2<T2, T3, R>;
    // (undocumented)
    <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2): Function1<T3, R>;
    // (undocumented)
    <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): Function0<R>;
    // (undocumented)
    <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>): Function4<T1, T2, T3, T4, R>;
    // (undocumented)
    <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1): Function3<T2, T3, T4, R>;
    // (undocumented)
    <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2): Function2<T3, T4, R>;
    // (undocumented)
    <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3): Function1<T4, R>;
    // (undocumented)
    <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): Function0<R>;
}

// @public
export const partialFirst: <T1, T2, R>(aFunction: BiFunction<T1, T2, R>, aFirst: T1) => UnaryFunction<T2, R>;

// @public
export const partialLeft: Partial;

// @public
export const partialSecond: <T1, T2, R>(aFunction: BiFunction<T1, T2, R>, aSecond: T2) => UnaryFunction<T1, R>;

// @public (undocumented)
export function pathForSearch(aPath: string): string;

// @public (undocumented)
export function perfMeasure(aName: string): () => void;

// @public
export type PlaceholderResolver = UnaryFunction<string[], Observable<RenderingContext[]>>;

// @public @deprecated
export const pluckApiOrigin: Generator<OperatorFunction<RenderingContextV2, string>>;

// @public @deprecated (undocumented)
export const pluckCurrentPage: Generator<OperatorFunction<RenderingContextV2, DeliveryContentItem>>;

// @public
export const pluckLocale: UnaryFunction<LocalizedText, Locale>;

// @public
export function pluckPath<T>(aPath: string[], aDefault?: T): UnaryFunction<any, T>;

// @public
export const pluckProperty: <T, K extends keyof T>(aKey: K, aDefault?: T[K]) => UnaryFunction<T, T[K]>;

// @public @deprecated
export const pluckResourceOrigin: Generator<OperatorFunction<RenderingContextV2, string>>;

// @public
export const pluckText: UnaryFunction<LocalizedText, string>;

// @public (undocumented)
export type Predicate<T> = (aValue: T | null | undefined) => boolean;

// @public
export const propertyFromObject: <T, K extends keyof T>(aValue: T, aDefault?: T[K]) => UnaryFunction<K, T[K]>;

// @public
export function queryToCanonicalString(aValue: any): string | null | undefined;

// @public
export function queryToString(aValue: any): string | null | undefined;

// @public
export function reduceArray<T, R>(aArray: ArrayLike<T> | null | undefined, aReducer: BiFunction<R, T, R>, aInitial: R): R;

// @public
export function reduceForIn<T, R>(aObject: Record<string, T> | object | null | undefined, aFunction: (aRes: R, aValue: T, aKey: string) => R, aInitial: R): R;

// @public
export function reduceToObject<T, V = T>(aArray: ArrayLike<T> | null | undefined, aKeyExtractor: UnaryFunction<T, string>, aTransformer?: UnaryFunction<T, V>): Record<string, V>;

// @public (undocumented)
export interface RenderingContextInterceptors {
    // (undocumented)
    opRenderingContext: MonoTypeOperatorFunction<RenderingContext>;
    // (undocumented)
    opRenderingContexts: MonoTypeOperatorFunction<RenderingContext[]>;
}

// @public (undocumented)
export interface RenderingContextMap {
    // (undocumented)
    [id: string]: RenderingContext;
}

// @public
export const replayLast: <T>(scheduler?: SchedulerLike) => MonoTypeOperatorFunction<T>;

// @public (undocumented)
export type Request<T> = (aUrl: string, aOptions: HttpOptions) => Observable<T>;

// @public
export function rxBackpressure<T, R>(aDelegate: UnaryFunction<T[], Observable<R>>): OperatorFunction<T, R>;

// @public
export function rxCachedFunction<T>(aDelegate: UnaryFunction<string, Observable<T>>, aAccessor?: CacheAccessor<Observable<T>>): UnaryFunction<string, Observable<T>>;

// @public (undocumented)
export interface RxCompose {
    // (undocumented)
    <T1, T2>(aOp1: OperatorFunction<T1, T2>): OperatorFunction<T1, T2>;
    // (undocumented)
    <T1, T2, T3>(aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>): OperatorFunction<T1, T3>;
    // (undocumented)
    <T1, T2, T3, T4>(aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>, aOp3: OperatorFunction<T3, T4>): OperatorFunction<T1, T4>;
    // (undocumented)
    <T1, T2, T3, T4, T5>(aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>, aOp3: OperatorFunction<T3, T4>, aOp4: OperatorFunction<T4, T5>): OperatorFunction<T1, T5>;
    // (undocumented)
    <T1, T2, T3, T4, T5, T6>(aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>, aOp3: OperatorFunction<T3, T4>, aOp4: OperatorFunction<T4, T5>, aOp5: OperatorFunction<T5, T6>): OperatorFunction<T1, T6>;
    // (undocumented)
    <T1, T2, T3, T4, T5, T6, T7>(aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>, aOp3: OperatorFunction<T3, T4>, aOp4: OperatorFunction<T4, T5>, aOp5: OperatorFunction<T5, T6>, aOp6: OperatorFunction<T6, T7>): OperatorFunction<T1, T7>;
    // (undocumented)
    <T1, T2, T3, T4, T5, T6, T7, T8>(aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>, aOp3: OperatorFunction<T3, T4>, aOp4: OperatorFunction<T4, T5>, aOp5: OperatorFunction<T5, T6>, aOp6: OperatorFunction<T6, T7>, aOp7: OperatorFunction<T7, T8>): OperatorFunction<T1, T8>;
    // (undocumented)
    <T, R>(...operations: Array<OperatorFunction<any, any>>): OperatorFunction<T, R>;
}

// @public @deprecated (undocumented)
export const rxCompose: RxCompose;

// @public
export const rxError: <T>(aLogger: Logger, ...aArgs: any[]) => (...aValues: any[]) => MonoTypeOperatorFunction<T>;

// @public
export function rxLayoutIdFromRenderingContext(aLayoutMode: string, aRenderingContext: Maybe<RenderingContextV2>, aTypeAccessor: UnaryFunction<string, Observable<AuthoringType>>, aLayoutMappingAccessor: UnaryFunction<string, Observable<AuthoringLayoutMapping>>, aLogSvc?: LoggerService, aScheduler?: SchedulerLike): Observable<string>;

// @public
export const rxLog: <T>(aMode: number) => (aLogger: Logger, ...aArgs: any[]) => (...aValues: any[]) => MonoTypeOperatorFunction<T>;

// @public
export const rxLogAll: <T>(aLogger: Logger, ...aArgs: any[]) => (...aValues: any[]) => MonoTypeOperatorFunction<T>;

// @public
export enum RxLogger {
    // (undocumented)
    ALL = 7,
    // (undocumented)
    DONE = 2,
    // (undocumented)
    ERROR = 4,
    // (undocumented)
    NEXT = 1
}

// @public
export const rxLogMember: <T>(aMode: number) => (aLogger$: Observable<Logger>, ...aArgs: any[]) => (...aValues: any[]) => MonoTypeOperatorFunction<T>;

// @public
export const rxLogNext: <T>(aLogger$: Observable<Logger>, ...aArgs: any[]) => (...aValues: any[]) => MonoTypeOperatorFunction<T>;

// @public
export const rxMemoize: <T, R>(opFct: OperatorFunction<T, R>, cmp?: EqualsPredicate<R>, scheduler?: SchedulerLike) => UnaryFunction<Observable<T>, Observable<R>>;

// @public
export const rxNext: <T>(aLogger: Logger, ...aArgs: any[]) => (...aValues: any[]) => MonoTypeOperatorFunction<T>;

// @public (undocumented)
export interface RxPipe {
    // (undocumented)
    <T1, T2>(aSrc: Observable<T1>, aOp1: OperatorFunction<T1, T2>): Observable<T2>;
    // (undocumented)
    <T1, T2, T3>(aSrc: Observable<T1>, aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>): Observable<T3>;
    // (undocumented)
    <T1, T2, T3, T4>(aSrc: Observable<T1>, aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>, aOp3: OperatorFunction<T3, T4>): Observable<T4>;
    // (undocumented)
    <T1, T2, T3, T4, T5>(aSrc: Observable<T1>, aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>, aOp3: OperatorFunction<T3, T4>, aOp4: OperatorFunction<T4, T5>): Observable<T5>;
    // (undocumented)
    <T1, T2, T3, T4, T5, T6>(aSrc: Observable<T1>, aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>, aOp3: OperatorFunction<T3, T4>, aOp4: OperatorFunction<T4, T5>, aOp5: OperatorFunction<T5, T6>): Observable<T6>;
    // (undocumented)
    <T1, T2, T3, T4, T5, T6, T7>(aSrc: Observable<T1>, aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>, aOp3: OperatorFunction<T3, T4>, aOp4: OperatorFunction<T4, T5>, aOp5: OperatorFunction<T5, T6>, aOp6: OperatorFunction<T6, T7>): Observable<T7>;
    // (undocumented)
    <T1, T2, T3, T4, T5, T6, T7, T8>(aSrc: Observable<T1>, aOp1: OperatorFunction<T1, T2>, aOp2: OperatorFunction<T2, T3>, aOp3: OperatorFunction<T3, T4>, aOp4: OperatorFunction<T4, T5>, aOp5: OperatorFunction<T5, T6>, aOp6: OperatorFunction<T6, T7>, aOp7: OperatorFunction<T7, T8>): Observable<T8>;
    // (undocumented)
    <T, R>(aSrc: Observable<T>, ...operations: Array<OperatorFunction<any, any>>): Observable<R>;
}

// @public
export const rxPipe: RxPipe;

// @public
export const rxPluckPath: <T>(aPath: string[], aDefault?: T) => OperatorFunction<any, T>;

// @public
export const rxSelectPath: <T, R>(aPath: string | string[], aDefault?: Maybe<R>, aCmp?: EqualsPredicate<R>, aScheduler?: SchedulerLike) => OperatorFunction<T, R>;

// @public
export const rxSelectProperty: <T, K extends keyof T>(aKey: K, aDefault?: Maybe<T[K]>, aCmp?: EqualsPredicate<T[K]>, aScheduler?: SchedulerLike) => OperatorFunction<T, T[K]>;

// @public
export function rxUrlFromProvider(aProvider: HubInfoUrlProvider): Observable<URL>;

// @public
export function rxWchFromAuthoringTypeByAccessor<T>(aAccessor: string, aTypeId: string, aSelector: UnaryFunction<AuthoringElement, T>, aTypeAccessor: UnaryFunction<string, Observable<AuthoringType>>, aScheduler?: SchedulerLike): Observable<T>;

// @public
export function rxWithSubscriptionCount<T>(aCallback: Consumer<number>): MonoTypeOperatorFunction<T>;

// @public
export function safeCmp<T>(aComparator: Comparator<T>): Comparator<T>;

// @public (undocumented)
export const safeMergeMap: <T, R>(aDelegate: UnaryFunction<T, ObservableInput<R>>) => OperatorFunction<T, R>;

// @public (undocumented)
export const safeSwitchMap: <T, R>(aDelegate: UnaryFunction<T, ObservableInput<R>>) => OperatorFunction<T, R>;

// @public
export const safeUnsubscribe: (aSubscription: Unsubscribable) => void;

// @public
export const safeUnsubscribeAll: (aSubscriptions: ArrayLike<Unsubscribable>) => void;

// @public (undocumented)
export const SEARCH_MAX_ROWS = 2147483647;

// @public (undocumented)
export const selectApiUrl: UnaryFunction<UrlConfig, URL>;

// @public (undocumented)
export const selectBaseUrl: UnaryFunction<UrlConfig, URL>;

// @public (undocumented)
export const selectPreviewMode: UnaryFunction<UrlConfig, boolean>;

// @public (undocumented)
export const selectResourceUrl: UnaryFunction<UrlConfig, URL>;

// @public
export function sendJsonRequest<T>(aUrl: string, aOptions: HttpOptions, aTrigger: Observable<any>, aHttpService: HttpService, aLogger?: Logger): Observable<T>;

// @public
export function sendRequest<T>(aUrl: string, aOptions: HttpOptions, aTrigger: Observable<any>, aRequest: Request<T>, aLogger: Logger): Observable<T>;

// @public
export function sendTextRequest(aUrl: string, aOptions: HttpOptions, aTrigger: Observable<any>, aHttpService: HttpService, aLogger?: Logger): Observable<string>;

// @public
export const shallowEquals: (aLeft: any, aRight: any) => boolean;

// @public @deprecated (undocumented)
export const shareLast: <T>() => MonoTypeOperatorFunction<T>;

// @public
export function siteContextEquals(aLeft: SiteContext, aRight: SiteContext): boolean;

// @public (undocumented)
export class SiteInformation {
    constructor();
    getIdByPath(path: string): Observable<string | null | undefined>;
    getSiteContextById(aID: string | null): SiteContext;
    // (undocumented)
    observer: Observer<Site>;
    get site(): Observable<Site>;
    }

// @public (undocumented)
export interface SpreadArgs {
    // (undocumented)
    <T1, R>(fct: (arg1: T1) => R): (args: [T1]) => R;
    // (undocumented)
    <T1, T2, R>(fct: (arg1: T1, arg2: T2) => R): (args: [T1, T2]) => R;
    // (undocumented)
    <T1, T2, T3, R>(fct: (arg1: T1, arg2: T2, arg3: T3) => R): (args: [T1, T2, T3]) => R;
    // (undocumented)
    <T1, T2, T3, T4, R>(fct: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R): (args: [T1, T2, T3, T4]) => R;
    // (undocumented)
    <T1, T2, T3, T4, T5, R>(fct: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => R): (args: [T1, T2, T3, T4, T5]) => R;
}

// @public
export const spreadArgs: SpreadArgs;

// @public
export class StaticResources {
    constructor(aBaseUrl: URL | undefined, http: HttpService);
    get(aKey: string): Observable<JSONValue>;
    }

// @public
export const switchMapDefault: <T>(aDefault: Observable<T>) => MonoTypeOperatorFunction<T>;

// @public
export const ternary: <T, R>(aPredicate: Predicate<T>, aLeft: UnaryFunction<T, R>, aRight: UnaryFunction<T, R>) => UnaryFunction<T, R>;

// @public
export function thisThenThat<T>(aFirst: Observable<T>, aNext: Observable<T>): Observable<T>;

// @public
export const thisThenThats: <T>(...aObservables: Observable<T>[]) => Observable<T>;

// @public
export const toArray: <T>(aValue: ArrayLike<T>) => T[];

// @public
export function toInteger(aValue: any, aDefault: number): number;

// @public
export const TRUE$: Observable<boolean>;

// @public
export const typedPluck: <T, K extends keyof T & string>(aKey: K) => OperatorFunction<T, T[K]>;

// @public
export const unary: <T, R>(aFunction: UnaryFunction<T, R>) => UnaryFunction<T, R>;

// @public
export const UNDEFINED$: Observable<any>;

// @public (undocumented)
export const UNDEFINED_RENDERING_CONTEXT: RenderingContext;

// @public (undocumented)
export const UNDEFINED_TYPE: "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function";

// @public
export function urlConfigEquals(aLeft: UrlConfig, aRight: UrlConfig): boolean;

// @public
export function urlEquals(aLeft: URL, aRight: URL): boolean;

// @public
export function urlFromProvider(aProvider: StaticHubInfoUrlProvider): URL;

// @public
export function urlSlashes(aUrl?: string): string;

// @public
export function urlToString(aURL: URL | string): string;

// @public
export const VERSION: {
    version: {
        major: string;
        minor: string;
        patch: string;
    };
    build: Date;
};

// @public (undocumented)
export function wchAddDebug(aPath: string, aRenderingContext: RenderingContext): RenderingContext;

// @public
export function wchAddTypings(aRenderingContext: RenderingContext): RenderingContext;

// @public
export function wchAdjustRenderingContextSearchQuery(aQuery: string): string;

// @public
export function wchAdjustSitePagesSearchQuery(aQuery: string, aSiteId: string): string;

// @public
export function wchAuthoringElementFromAccessor(aAccessor: string, aType: AuthoringType): Maybe<AuthoringElement>;

// @public
export function wchBoxFetchLevels(aLevels: number | null | undefined, aDefault?: number): number;

// @public
export function wchBoxLayoutMode(aMode: string | null | undefined): string;

// @public
export function wchCreateUrlConfig(aBaseUrl?: HubInfoUrlProvider, aApiUrl?: HubInfoUrlProvider, aResourceUrl?: HubInfoUrlProvider, aDocument?: Document): Observable<UrlConfig>;

// @public (undocumented)
export function wchCycleHandling(aCycle?: CYCLE_HANDLING | string): CYCLE_HANDLING;

// @public
export function wchDecodeAccessor(aPrototype: any, aAccessor: string): string | undefined;

// @public
export function wchDecodeExpression(aExpression: string): string;

// @public
export function wchDeliveryContentByAccessor(aItem: DeliveryContentItem, aAccessor: string): DeliveryContentItem | DeliveryElement;

// @public
export function wchElementFromRenderingContext(aContext: RenderingContext, aAccessor: string): AbstractElement;

// Warning: (ae-forgotten-export) The symbol "RenderingContextCallback" needs to be exported by the entry point public_api.d.ts
//
// @public
export function wchForEachRenderingContext(aRenderingContext: RenderingContext, aCallback: RenderingContextCallback): void;

// @public
export function wchForEachType(aType: AuthoringType, aCallback: Consumer<AuthoringType>): void;

// @public
export function wchGetApiUrlFromResourceURL(aResourceURL: URL): URL;

// @public
export function wchGetApiUrlInContext(aApiUrl: URL, aBaseURL: URL, aPreviewCheck: UnaryFunction<URL, boolean>): URL;

// @public
export function wchGetBaseURL(aDocument?: Document, aWindow?: Window): URL;

// @public
export function wchGetHubInfoFromBaseURL(aBaseURL: URL): HubInfo;

// @public
export function wchGetHubInfoFromLinks(aDocument?: Document, aWindow?: Window): HubInfo;

// @public
export function wchGetHubInfoUrlProvider(aApiUrl: HubInfoUrlProvider, aPreviewCheck?: UnaryFunction<URL, boolean>): HubInfoUrlProvider;

// @public
export function wchGetLayout(aLayoutMode: string | undefined, aContext: RenderingContext | undefined): Layout | undefined;

// @public
export function wchGetPageSearchURL(aPath: string, aSiteId: string): Observable<string>;

// @public
export function wchGetParentPageURL(aParentId: string, aSiteId: string): Observable<string>;

// @public
export function wchGetSearchURL(aQueryString: string): Observable<string>;

// @public
export function wchGetSiteContextURL(aParentId: string | null | undefined, aPageId: string, aSiteId: string): Observable<string>;

// @public
export const wchGetSiteURL: UnaryFunction<string, string>;

// @public (undocumented)
export function wchInsertPlaceholders(aRenderingContext: RenderingContext, aResolver: PlaceholderResolver): Observable<RenderingContext>;

// @public
export function wchIsPreviewMode(aBaseURL: URL): boolean;

// @public
export function wchPlaceholderFromAccessor(aAccessor: string, aType: AuthoringType): Maybe<AuthoringPlaceholder>;

// @public
export function wchPlaceholderResolver(aTag: string, aSearch: WchSdkSearch): PlaceholderResolver;

// @public
export function wchPrepareRenderingContextInterceptors(aRenderingContextInterceptors: RenderingContextInterceptor[]): RenderingContextInterceptors;

// @public
export function wchResolveRenderingContext(aRenderingContext: RenderingContext | null | undefined, aStrategy: CYCLE_HANDLING, aRenderingContextById: (id: string) => Observable<RenderingContext | null | undefined>, aLogger?: Logger): Observable<RenderingContext | null | undefined>;

// @public
export function wchResolveType(aType: AuthoringType): AuthoringType;

// @public
export function wchSelectAccessor(aAccessor: string): UnaryFunction<any, any>;

// @public
export function wchTypeFromAccessor(aAccessor: string, aType: AuthoringType): Maybe<string>;

// @public
export const zipArgs: ZippedArgs;

// @public (undocumented)
export interface ZippedArgs {
    // (undocumented)
    <T1>(arg1: T1): [T1];
    // (undocumented)
    <T1, T2>(arg1: T1, arg2: T2): [T1, T2];
    // (undocumented)
    <T1, T2, T3>(arg1: T1, arg2: T2, arg3: T3): [T1, T2, T3];
    // (undocumented)
    <T1, T2, T3, T4>(arg1: T1, arg2: T2, arg3: T3, arg4: T4): [T1, T2, T3, T4];
    // (undocumented)
    <T1, T2, T3, T4, T5>(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): [T1, T2, T3, T4, T5];
}


```
